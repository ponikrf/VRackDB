[[_TOC_]]

Установка
---------

Установка через npm:

```
# npm install -s vrack-db
```

Начало работы
--------------

Инициализация:

```ts
import { Database } from "vrack-db";
// OR
const { Database } = require('vrack-db')

// Create instance of Database
const DB = new Database()
```

При необходимости можно создать несколько экземпляров независимых баз данных.

Схемы
------

Схемы определяют как долго и с какой точностью будут хранится данные. Принадлежность метрики к схеме определяется ее именем.

Пример добавление схемы:

```ts
DB.scheme('test', 'test.name', '5s:10m, 1m:2h')
```

 - **name** _test_ - Название схемы
 - **pattern** _test.name_ - Все метрики с именем `test.name.*` будут попадать в группу `test`. 
 - **retentions** _5s:10m, 1m:2h_ - Указания точности и размера периода хранения метрик.

**Name** должно быть уникальным. Старайтесь не делать его длинным. Пример `boilers`,`houses`, `memory`,`downloads`. 

**Pattern** пишется маленькими буквами и использует в качестве разделителя актетов символ точки '.'. Когда вы пишите в базу данных метрику с именем `test.name.1`, база ищет подходящую схему и применяет к ней правила схемы.

**Retentions** (`5s:10m, 1m:2h`) указывает настройку слоев. Каждое значение через запятую добавляет в схему слой с определенной точностью и общим периодом. 

Что же такое слой? Слой это хранилище данных, которое распределяет данные внутри себя по ячейкам памяти, в зависимости от длинны слоя и его точности. Метрики же обычно хранятся на нескольких слоях. Например, вы хотите хранить данные за последний день с точностью 5 секунд, вы добавляете в схему `5s:1d`. Еще хотелось бы хранить данные с точностью 1 минута и длительностью неделю - теперь настройка схемы будет выглядеть `5s:1d, 1m:1w`. 

Вы сами должны оценивать, какую точность и на какой дистанции вы хотите хранить данные для решения ваших задач. 

Значение типа `5s`, `10m`, `2h`, являются интервалами которые можно расшифровывать как `5 секунд`, `10 минут`, `2 часа`. 

Вот список поддерживаемых интервалов:

- s - секунды
- m - минуты
- h - часы
- d - дни
- w - недели
- mon - месяцы
- y - годы

Интервалы начинаются с целого числа, после которого сразу идет тип интервала, например `1m`, `10d`,`120s`,`1y`.

Учитывайте что слои идут не друг за другом, а располагаются друг на другом. Поэтому если ваш самый длинный слой вмещает в себя год, все что дольше года вы будете терять.

Если название метрики не подходит ни под один паттерн, будет использована схема по умолчанию:

```ts
{
    name: 'default',
    pattern: '*',
    retentions: '5s:10m, 1m:2h, 15m:1d, 1h:1w, 6h:1m, 1d:1y',
}
```

-----

**Схема по умолчанию рассчитана на примерно 120 значений на слой. Это очень мало! Пожалуйста **обязательно** создавайте собственные схемы хранения с большей точностью на период.**

-----

Проверка существования схемы:
```ts
DB.schemeHas('schemeName') // return boolean
```

Получения списка метрик схемы:
```ts
DB.schemeMetrics('schemeName') // return ['test.name.metricid',...]
```

На данный момент нет возможности получить внутренние настройки схемы. Внесение изменений в них может привести к непредвиденным последствиям. Поскольку вы сами создаете схемы, лучшим решением будет хранение (дублирование) настроек схемы вне класса `Database` либо использовать наследование классов.

### Подсчет занимаемого места

Вы можете предварительно узнать сколько будет занимать ваша метрика в памяти, для этого вы можете разделить (лучше это делать в секундах) период на интервал. Полученное значение и есть количество ячеек памяти для этого слоя. Умножив полученное значение на 12, вы получите размер слоя в байтах. Таким образом, вы можете прикинуть сколько вы хотите хранить и с какой точностью. 

-----

**Не забывайте! Вы платите оперативной памятью за точность** 

-----

Получения размера для метрики (не рекомендуется) используя `Collector`, например:

```ts
DB.Collector.size('test.name'); 
```

Но лучше смотреть сколько занимает вся схема и все метрики внутри нее:

```ts
DB.schemeSize('test')
```

Получить список всех созданных схем на данный момент:

```ts
DB.schemeList() // вернет ['default', 'test']
```

Высвободить память, удалив всю схему:
```ts
DB.schemeDestroy('test')
```

Запись данных
-------------

Запись метрики в базу:

```ts
DB.write("test.name.metricid", 1234.5678)
```

Где:

 - `test.name.metricid` - Название метрики, указываются так же, как и паттерны
 - `1234.5678` - **Значение для метрики имеет тип float(32bit)**.

По умолчанию данные в базу всегда записываются от "сейчас".

Указание времени:

```ts
DB.write("test.name.metricid", 1234.5678, 123456789)
```

По умолчанию время равно `0`. Если значение `0`, то текущее время будет установлено в `now`. 
Если вы используете абстрактные значения для указания времени, они должны начинаться со значения > 0.

Учитывайте, что все вычисления в базе данных ведутся в секундах. Нельзя использовать в качестве индекса времени число с плавающей точкой.

### Модификаторы

Запись в базу производится по индексу времени в рамках каждого слоя. Такое поведение вызвано особенностью работы слоя, который не может хранить данные чаще, чем точность слоя. Для того, чтобы компенсировать часть проблем, связанных с этой особенностью, можно применять разные модификаторы значения при записи.

Указание модификатора значения:

```ts
DB.write("test.name.metricid", 1234.5678, 0, 'sum')
```

Вот их список:

 - **last** - Постоянно перезаписывает значение индекса метрики
 - **first** - Оставляет первое записываемое значение метрики
 - **max** - Перезаписывает значение, если новое значение больше старого
 - **min** - Перезаписывает значение, если новое значение меньше старого
 - **avg** - Вычисляет среднее значение между текущим и предыдущим
 - **sum** - Прибавляет текущее значение к прошлому

**По умолчанию**, данные всегда записываются, **используя модификатор `last`**. Пожалуйста учитывайте это.

Получения данных
----------------

Получение данных с помощью упрощенной записи периода.

```ts
DB.read('test.name.metricid', 'now-6h:now', '15m')
```

Где:

 - `test.name.metricid` - Название метрики
 - `now-6h:now` - Относительный период
 - `15m` - Интервал

Такой запрос вернет все записи за последние 6 часов с точностью 15 минут. Указание `now` с вычислением (прим. `now-15m:now`) можно использовать только в методе `Database.read`.

Пример ответа:

```json
{
   "relevant": true,
   "start": 1697826000,
   "end": 1697829600,
   "rows": [
      {
          "time": 1697826000,
          "value": 4.7855000495910645
      },
      {
          "time": 1697826300,
          "value": 4.797100067138672
      },
      ...
   ]
}
```

Если данная метрика не была инициализирована, запрос вернет все значения равные `null` и флаг `relevant` равный `false`.

Можно использовать метод запроса с указанием произвольного времени периода.

```ts
// Interval.now() Возвращает время в секундах
const start = Interval.now() - 1000 // начало = сейчас - 1000 секунд
const end = Interval.now()
DB.readCustomRange("test.name.metricid", start, end, '15m', 'avg')
```

Рекомендуется использовать упрощенный способ указания периода. Подходит для реализации пресетов с указанием определенной точности и дальности просмотра метрики.

Любой интервал всегда приводится к секундам, поэтому, если есть необходимость указать интервал в секундах, проще всего сформировать строку с интервалом и нужным количеством секунд.

```ts
DB.readCustomRange("test.name.metricid", start, end, intervalInSec + 's', 'avg')
```

Иногда удобнее получать всегда одно и тоже количество точек независимо от периода. Такое поведение для графика более ожидаемо для пользователя. Пользователь всегда видит одинаковое количество точек на график независимо от пресетов типа 'now-1d:now', 'now-1w:now', 'now-1mon:now'.

Для этого вы можете указать вместо интервала - количество точек.

```ts
DB.read('test.name.metricid', 'now-6h:now', 300)
```

Учитывайте что минимальное значения для интервала может быть 1s, это значит, что если в переданный период не будет вмещаться 300 точек, количество точек будет сокращаться пропорционально размеру периода. В любом случае такое поведение считается условно безопасным и не приведет к запросу с очень большим количеством точек на график.

### Агрегация

Функции чтения из базы данных поддерживают несколько базовых функций агрегации данных. Данные функции будут применяться к набору данных внутри интервалов периода. 

По умолчанию используется функция `last`.

Список доступных функций:
 
- **last** - Вернет последнее не `null` значение, если все значения `null` - вернет null
- **first** - Вернет первое не `null`  значение, если все значения `null` - вернет null
- **max** - Возвращает максимальное значение, если все значения `null` - вернет null
- **min** - Возвращает минимальное значение, если все значения `null` - вернет null
- **avg** - Возвращает среднее значение, если все значения `null` - вернет null
- **sum** - Возвращает сумму значений, если все значения `null` - вернет null
 
Пример использования:
```ts
DB.read('test.name.metricid', 'now-6h:now', '15m','avg')
```

Можно воспользоваться классом `MetricResult` для применения функции агрегации к результатам запроса метрик. Это может быть полезно, например, для получения максимального и минимального значения в выборке.

```ts
const data = DB.read('test.name.metricid', 'now-6h:now', '15m','avg')
const dataMax = MetricResult.aggregate(data, 'max') // Вернет число или null
```

Поиск доступных метрик
-----------------------

Если вы используете класс `Database`, вы можете включить дерево метрик. Дерево метрик позволяет производить поиск метрик по маске. 

Для включения дерева метрик, необходимо при создании класса `Database` указать параметр `metricTree: true`:

```ts
const DB = new Database({ metricTree:true })
```

Например если вы хотите найти все метрики с паттерном `test.list.*`, вы можете получить их с помощью метода `find` класса `MetricTree`:

```ts
 DB.MetricTree.find('test.list.*')
```

Такой запрос вернет массив путей/метрик:

```ts
[{
   leaf: true, // Is the path a finite path (false if the path is a list)
   name: 'name', // Act name
   path: 'test.list.name', // Full path
}]
```

Дерево метрик очень дорогое для использования памяти, пожалуйста учитывайте это. Если вы хотите экономить память, вы можете сократить название метрик максимально. 

Продвинутые функции
-------------------

### Оптимизация схем


Оптимизация схем относится больше к продвинутым функциям. Если вам нужно прямо сейчас начать работать с базой, рекомендуется пропустить этот пункт.

Слои поддерживают разные хранилища для оптимизации хранения данных. По умолчанию сейчас используются хранилища `Uint64` для хранения времени и `Float` для хранения значения.

Такие хранилища могут быть не особо оптимальны например для хранения булевых значений, или если в качестве меток времени используется не реальное время, а числовые метки маленьких значений.

Для оптимизации хранения можно указать конкретные хранилища значений и времени. 

```ts
DB.scheme('test', 'test.name.bit', '10s:3h, 2m:1d, 30m:3mon, 1h:1y', StorageTypes.Bit, StorageTypes.Uint64)
```

Теперь в качестве значений для метрик с именем `test.name.bit.1` могут использоваться только битовые значения (0,1). В памяти на каждые 8 метрик в этой группе будет выделено всего 1 байт памяти что в 32 раз меньше чем если бы использовался стандартный тип памяти.

Нужно учитывать что хранилище времени должно вмещать нужный индекс на 100%. Например, если мы выберем тип для хранилища времени `Uint8`, и попытаемся записать значение 256, мы фактически запишем значение 0 в метку времени, что приведет к смещение `startTime` и `endTime` слоя. Такое повередние может привести к потере данных. Поэтому при выборе хранилища для времени нужно что бы записываемые значения всегда вмещались в этот тип. 

Естественно для хранилища индекса времени необходимо использовать только целочисленные типы данных. Иначе это может привести к непредсказуемым последствиям при округлении чисел к точности слоя. 

Поддерживаются следующие типы:

 - Bit - Битовое значение 1 или 0
 - Double - Число с плавающей точкой (размер 64 bit) 
 - Float - Число с плавающей точкой (размер 32 bit)
 - Int8 - Целое число до 127 (может быть отрицательным)
 - Int16 - Целое число до 32 767 (может быть отрицательным)
 - Int32 - Целое число до 2 147 483 647 (может быть отрицательным)
 - Int64 - Целое число до 9 223 372 036 854 775 807 (может быть отрицательным)
 - Uint8 - Целое число от 0 до 255
 - Uint16 - Целое число от 0 до 65 535  
 - Uint32 - Целое число от 0 до 294 967 295 
 - Uint64 - Целое число от 0 до 18 446 744 073 709 551 615


### Работа со временем слоев

Если вы используете базу данных для кеширования данных, вы можете столкнутся с проблемой получения данных относительным периодом. Условно говоря вы взяли старые данные и записали их в базу. Как вам узнать начало и конец графика?

На самом деле лучше вычислять начало и конец графика до записи в базу, либо во время записи. Особенность слоя такова, что он не представляет, где находится начало и конец графика. Хотя если данные в график поступают последовательно, слой знает где находится конец графика.

Что же делать с началом графика?

В любом случае нам нужно сохранить первый индекс времени.

```ts
let start = firstValue.time
DB.write('test.metric',firstValue.value, firstValue.time)
``` 

Теперь если при запросе из базы указать в качестве начала времени `start` можно получить часть начала графика пустым. Такое может произойти из-за того, что данные не влезли даже в самый большой слой схемы. 

Что бы исправить эту неприятность, можно провести проверку начала графика.

```ts
const layers = DB.Collector.layers('test.metric')
const fLayer = layers[0].layer // first layer
const lLayer = layers[layers.length - 1].layer // last layer
if (start < fLayer.startTime) start = fLayer.startTime
DB.readCustomRange('test.metric', start, lLayer.endTime, 600)
``` 

Теперь `start` всегда начало графика, за пределы которого смотреть нету смысла. Конец графика определяется концом самого точного слоя.

Давайте рассмотрим другой пример - "бесконечный" график.

В некоторых ситуация бывает необходимо строить "бесконечный" график. Такой график набирает например 600 точек, после чего происходит только модификация данных внутри графика. Набор данных в такой график как бы постоянно сжимает его, при этом график не смещается во времени.

Высокая точность тут важна только на первый набор значений, потом можно использовать слой с меньшей точностью. Например мы получаем данные каждую секунду, добавим слой `1s:10m`, он будет занимать примерно 8KB памяти и вмещать наши 600 точек. Далее нам необходимо добавит слой который бы взял на себя основную нагрузку на хранения по времени. Пока мы добавили слой для хранения только 10 минут, добавим слой на 3 часа с таким же количеством точек `18s:3h`. Далее можно уже добавлять все менее и менее точные слои, например `2m:1d`, `1h:1mon`.

Конечно график не будет бесконечным и все таки через месяц он уже начнет смещаться, но обычно такое количество времени не требуется для сбора временных данных бесконечного графика.

Теперь разберемся, с запросом на получение бесконечного графика. Для начала, нам необходимо сохранить время самой первой метрики.

```ts
const start = Interval.now()
DB.write('test.metric',2.24, start)
// ...
```
Далее мы уже можем запрашивать данные со статическим значением количества точек.

```ts
const end = Interval.now()
DB.readCustomRange('test.metric', start, end, 600)
```

Такое решение будет работать пока разница между start и end не превысит длинну максимально большого слоя (в данном случае месяц). Конечно вероятность, что это случится очень маленькая, он она есть и если ничего не сделать то график начнет сжиматься "пустыми" значениями от начала к центру.

Что бы избавится от этой проблемы, мы можем взять первый слой (он будет самый длинный) и каждый раз сверять начало со временем начала этого слой.

```ts
const layers = DB.Collector.layers('test.metric')
const fLayer = layers[0].layer
// ...
// Каждый раз перед получением данных
if (start < fLayer.startTime) start = fLayer.startTime
``` 

Решение для обоих проблем схожее и на практике показывают, как можно использовать время слоев для решения своих задач.

