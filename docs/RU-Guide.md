[[_TOC_]]

Установка
---------

Установка через npm:

```
# npm install -s vrack-db
```

Начало работы
--------------

Инициализация:

```ts
import { Database } from "vrack-db";
// OR
const { Database } = require('vrack-db')

// Create instance of Database
const DB = new Database()
```

При необходимости можно создать несколько экземпляров независимых баз данных.

Схемы
------

Схемы определяют как долго и с какой точностью будут хранится данные. Принадлежность метрики к схеме определяется ее именем.

Пример добавление схемы:

```ts
DB.scheme('test', 'test.name', '5s:10m, 1m:2h')
```

 - **name** _test_ - Название схемы
 - **pattern** _test.name_ - Все метрики с именем `test.name.*` будут попадать в группу `test`. 
 - **retentions** _5s:10m, 1m:2h_ - Указания точности и размера периода хранения метрик.

**Name** должно быть уникальным. Старайтесь не делать его длинным. Пример `boilers`,`houses`, `memory`,`downloads`. 

**Pattern** пишется маленькими буквами и использует в качестве разделителя актетов символ точки '.'. Когда вы пишите в базу данных метрику с именем `test.name.1`, база ищет подходящую схему и применяет к ней правила схемы.

**Retentions** (`5s:10m, 1m:2h`) указывает настройку слоев. Каждое значение через запятую добавляет в схему слой с определенной точностью и общим периодом. 

Что же такое слой? Слой это хранилище данных, которое распределяет данные внутри себя по ячейкам памяти, в зависимости от длинны слоя и его точности. Метрики же обычно хранятся на нескольких слоях. Например, вы хотите хранить данные за последний день с точностью 5 секунд, вы добавляете в схему `5s:1d`. Еще хотелось бы хранить данные с точностью 1 минута и длительностью неделю - теперь настройка схемы будет выглядеть `5s:1d, 1m:1w`. 

Вы сами должны оценивать, какую точность и на какой дистанции вы хотите хранить данные для решения ваших задач. 

Значение типа `5s`, `10m`, `2h`, являются интервалами которые можно расшифровывать как `5 секунд`, `10 минут`, `2 часа`. 

Вот список поддерживаемых интервалов:

- s - секунды
- m - минуты
- h - часы
- d - дни
- w - недели
- mon - месяцы
- y - годы

Интервалы начинаются с целого числа, после которого сразу идет тип интервала, например `1m`, `10d`,`120s`,`1y`.

Учитывайте что слои идут не друг за другом, а располагаются друг на другом. Поэтому если ваш самый длинный слой вмещает в себя год, все что дольше года вы будете терять.

Если название метрики не подходит ни под один паттерн, будет использована схема по умолчанию:

```ts
{
    name: 'default',
    pattern: '*',
    retentions: '5s:10m, 1m:2h, 15m:1d, 1h:1w, 6h:1m, 1d:1y',
}
```

-----

**Схема по умолчанию рассчитана на примерно 120 значений на слой. Это очень мало! Пожалуйста **обязательно** создавайте собственные схемы хранения с большей точностью на период.**

-----

Проверка существования схемы:
```ts
DB.schemeHas('schemeName') // return boolean
```

Получения списка метрик схемы:
```ts
DB.schemeMetrics('schemeName') // return ['test.name.metricid',...]
```

На данный момент нет возможности получить внутренние настройки схемы. Внесение изменений в них может привести к непредвиденным последствиям. Поскольку вы сами создаете схемы, лучшим решением будет хранение (дублирование) настроек схемы вне класса `Database` либо использовать наследование классов.

### Подсчет занимаемого места

Вы можете предварительно узнать сколько будет занимать ваша метрика в памяти, для этого вы можете разделить (лучше это делать в секундах) период на интервал. Полученное значение и есть количество ячеек памяти для этого слоя. Умножив полученное значение на 12, вы получите размер слоя в байтах. Таким образом, вы можете прикинуть сколько вы хотите хранить и с какой точностью. 

-----

**Не забывайте! Вы платите оперативной памятью за точность** 

-----

Получения размера для метрики (не рекомендуется) используя `Collector`, например:

```ts
DB.Collector.size('test.name'); 
```

Но лучше смотреть сколько занимает вся схема и все метрики внутри нее:

```ts
DB.schemeSize('test')
```

Получить список всех созданных схем на данный момент:

```ts
DB.schemeList() // вернет ['default', 'test']
```

Высвободить память, удалив всю схему:
```ts
DB.schemeDestroy('test')
```

Запись данных
-------------

Запись метрики в базу:

```ts
DB.write("test.name.metricid", 1234.5678)
```

Где:

 - `test.name.metricid` - Название метрики, указываются так же, как и паттерны
 - `1234.5678` - **Значение для метрики имеет тип float(32bit)**.

По умолчанию данные в базу всегда записываются от "сейчас".

Указание времени:

```ts
DB.write("test.name.metricid", 1234.5678, 123456789)
```

По умолчанию время равно `0`. Если значение `0`, то текущее время будет установлено в `now`. 
Если вы используете абстрактные значения для указания времени, они должны начинаться со значения > 0.

Учитывайте, что все вычисления в базе данных ведутся в секундах. Нельзя использовать в качестве индекса времени число с плавающей точкой.

### Модификаторы

Запись в базу производится по индексу времени в рамках каждого слоя. Такое поведение вызвано особенностью работы слоя, который не может хранить данные чаще, чем точность слоя. Для того, чтобы компенсировать часть проблем, связанных с этой особенностью, можно применять разные модификаторы значения при записи.

Указание модификатора значения:

```ts
DB.write("test.name.metricid", 1234.5678, 0, 'sum')
```

Вот их список:

 - **last** - Постоянно перезаписывает значение индекса метрики
 - **first** - Оставляет первое записываемое значение метрики
 - **max** - Перезаписывает значение, если новое значение больше старого
 - **min** - Перезаписывает значение, если новое значение меньше старого
 - **avg** - Вычисляет среднее значение между текущим и предыдущим
 - **sum** - Прибавляет текущее значение к прошлому

**По умолчанию**, данные всегда записываются, **используя модификатор `last`**. Пожалуйста учитывайте это.

Получения данных
----------------

Получение данных с помощью упрощенной записи периода.

```ts
DB.read('test.name.metricid', 'now-6h:now', '15m')
```

Где:

 - `test.name.metricid` - Название метрики
 - `now-6h:now` - Относительный период
 - `15m` - Интервал

Такой запрос вернет все записи за последние 6 часов с точностью 15 минут. Указание `now` с вычислением (прим. `now-15m:now`) можно использовать только в методе `Database.read`.

Пример ответа:

```json
{
   "relevant": true,
   "start": 1697826000,
   "end": 1697829600,
   "rows": [
      {
          "time": 1697826000,
          "value": 4.7855000495910645
      },
      {
          "time": 1697826300,
          "value": 4.797100067138672
      },
      ...
   ]
}
```

Если данная метрика не была инициализирована, запрос вернет все значения равные `null` и флаг `relevant` равный `false`.

Можно использовать метод запроса с указанием произвольного времени периода.

```ts
// Interval.now() Возвращает время в секундах
const start = Interval.now() - 1000 // начало = сейчас - 1000 секунд
const end = Interval.now()
DB.readCustomRange("test.name.metricid", start, end, '15m', 'avg')
```

Рекомендуется использовать упрощенный способ указания периода. Подходит для реализации пресетов с указанием определенной точности и дальности просмотра метрики.

Любой интервал всегда приводится к секундам, поэтому, если есть необходимость указать интервал в секундах, проще всего сформировать строку с интервалом и нужным количеством секунд.

```ts
DB.readCustomRange("test.name.metricid", start, end, intervalInSec + 's', 'avg')
```

Иногда удобнее получать всегда одно и тоже количество точек независимо от периода. Такое поведение для графика более ожидаемо для пользователя. Пользователь всегда видит одинаковое количество точек на график независимо от пресетов типа 'now-1d:now', 'now-1w:now', 'now-1mon:now'.

Для этого вы можете указать вместо интервала - количество точек.

```ts
DB.read('test.name.metricid', 'now-6h:now', 300)
```

Учитывайте что минимальное значения для интервала может быть 1s, это значит, что если в переданный период не будет вмещаться 300 точек, количество точек будет сокращаться пропорционально размеру периода. В любом случае такое поведение считается условно безопасным и не приведет к запросу с очень большим количеством точек на график.

### Агрегация

Функции чтения из базы данных поддерживают несколько базовых функций агрегации данных. Данные функции будут применяться к набору данных внутри интервалов периода. 

По умолчанию используется функция `last`.

Список доступных функций:
 
- **last** - Вернет последнее не `null` значение, если все значения `null` - вернет null
- **first** - Вернет первое не `null`  значение, если все значения `null` - вернет null
- **max** - Возвращает максимальное значение, если все значения `null` - вернет null
- **min** - Возвращает минимальное значение, если все значения `null` - вернет null
- **avg** - Возвращает среднее значение, если все значения `null` - вернет null
- **sum** - Возвращает сумму значений, если все значения `null` - вернет null
 
Пример использования:
```ts
DB.read('test.name.metricid', 'now-6h:now', '15m','avg')
```

Можно воспользоваться классом `MetricResult` для применения функции агрегации к результатам запроса метрик. Это может быть полезно, например, для получения максимального и минимального значения в выборке.

```ts
const data = DB.read('test.name.metricid', 'now-6h:now', '15m','avg')
const dataMax = MetricResult.aggregate(data, 'max') // Вернет число или null
```

Поиск доступных метрик
-----------------------

Если вы используете класс `Database`, вы можете включить дерево метрик. Дерево метрик позволяет производить поиск метрик по маске. 

Для включения дерева метрик, необходимо при создании класса `Database` указать параметр `metricTree: true`:

```ts
const DB = new Database({ metricTree:true })
```

Например если вы хотите найти все метрики с паттерном `test.list.*`, вы можете получить их с помощью метода `find` класса `MetricTree`:

```ts
 DB.MetricTree.find('test.list.*')
```

Такой запрос вернет массив путей/метрик:

```ts
[{
   leaf: true, // Is the path a finite path (false if the path is a list)
   name: 'name', // Act name
   path: 'test.list.name', // Full path
}]
```

Дерево метрик очень дорогое для использования памяти, пожалуйста учитывайте это. Если вы хотите экономить память, вы можете сократить название метрик максимально. 

Продвинутые функции
-------------------

### Оптимизация схем


Оптимизация схем относится больше к продвинутым функциям. Если вам нужно прямо сейчас начать работать с базой, рекомендуется пропустить этот пункт.

Слои поддерживают разные хранилища для оптимизации хранения данных. По умолчанию сейчас используются хранилища `Uint64` для хранения времени и `Float` для хранения значения.

Такие хранилища могут быть не особо оптимальны например для хранения булевых значений, или если в качестве меток времени используется не реальное время, а числовые метки маленьких значений.

Для оптимизации хранения можно указать конкретные хранилища значений и времени. 

```ts
DB.scheme('test', 'test.name.bit', '10s:3h, 2m:1d, 30m:3mon, 1h:1y', StorageTypes.Bit, StorageTypes.Uint64)
```

Теперь в качестве значений для метрик с именем `test.name.bit.1` могут использоваться только битовые значения (0,1). В памяти на каждые 8 метрик в этой группе будет выделено всего 1 байт памяти что в 32 раз меньше чем если бы использовался стандартный тип памяти.

Нужно учитывать что хранилище времени должно вмещать нужный индекс на 100%. Например, если мы выберем тип для хранилища времени `Uint8`, и попытаемся записать значение 256, мы фактически запишем значение 0 в метку времени, что приведет к смещение `startTime` и `endTime` слоя. Такое повередние может привести к потере данных. Поэтому при выборе хранилища для времени нужно что бы записываемые значения всегда вмещались в этот тип. 

Естественно для хранилища индекса времени необходимо использовать только целочисленные типы данных. Иначе это может привести к непредсказуемым последствиям при округлении чисел к точности слоя. 

Поддерживаются следующие типы:

 - Bit - Битовое значение 1 или 0
 - Double - Число с плавающей точкой (размер 64 bit) 
 - Float - Число с плавающей точкой (размер 32 bit)
 - Int8 - Целое число до 127 (может быть отрицательным)
 - Int16 - Целое число до 32 767 (может быть отрицательным)
 - Int32 - Целое число до 2 147 483 647 (может быть отрицательным)
 - Int64 - Целое число до 9 223 372 036 854 775 807 (может быть отрицательным)
 - Uint8 - Целое число от 0 до 255
 - Uint16 - Целое число от 0 до 65 535  
 - Uint32 - Целое число от 0 до 294 967 295 
 - Uint64 - Целое число от 0 до 18 446 744 073 709 551 615


### Работа со временем слоев

Если вы используете базу данных для кеширования данных, вы можете столкнутся с проблемой получения данных относительным периодом. Условно говоря вы взяли старые данные и записали их в базу. Как вам узнать начало и конец графика?

С версии 2.3.0 появилась возможность получения предположительного начала и конца графика:

```ts
if ( DB.Collector.has(test.metric)){
    const startedAt = DB.Collector.start('test.metric')
    const endedAt = DB.Collector.end('test.metric')
}
``` 

Так же был добавлен специальный метод для получения всего графика:

```ts
// metric.id & points count
const result = DB.readAll('test.metric', 300)
``` 

С помощью этого метода можно легко строить "бесконечный" график. 

В некоторых ситуация бывает необходимо строить "бесконечный" график. Такой график набирает например 600 точек, после чего происходит только модификация данных внутри графика. Набор данных в такой график как бы постоянно сжимает его, при этом график не смещается во времени.

Высокая точность тут важна только на первый набор значений, потом можно использовать слой с меньшей точностью. Например мы получаем данные каждую секунду, добавим слой `1s:10m`, он будет занимать примерно 8KB памяти и вмещать наши 600 точек. Далее нам необходимо добавит слой который бы взял на себя основную нагрузку на хранения по времени. Пока мы добавили слой для хранения только 10 минут, добавим слой на 3 часа с таким же количеством точек `18s:3h`. Далее можно уже добавлять все менее и менее точные слои, например `2m:1d`, `1h:1mon`.


Конечно график не будет бесконечным и все таки через месяц он уже начнет смещаться, но обычно такое количество времени не требуется для сбора временных данных бесконечного графика.


Отслеживание данных
-------------------

С версии 2.1.0 появился инструмент `Alerting` для отслеживания и создании тревожных сообщений. 

Для использования этого инструмента необходим уже инициализированный класс `Database`. 

Инициализация:

```ts
const AT = new Alerting(DB)
```

Класс `Alerting` сам запрашивает данные из базы данных используя настройки определенные в классе `AlertQuery`. 

Пример создания класса настройки запроса, который будет запрашивать среднее значение каждые 5 секунд за последние 15 секунд:

```ts
const aQuery = new AlertQuery('5s', '1s', 'now-15s:now', 'avg')
```

 - **evaluateInterval** _5s_ - Интервал с которым будут запрашиваться данные
 - **interval** _1s_ - Интервал запроса
 - **period** _now-15s:now_ - Относительный периода запроса
 - **func** _avg_ - Функция агрегации запроса

Для определения условий используется класс `BasicCondition`:

```ts
// level, condition type, params
const aConfig = new BasicCondition('danger',"outRange",[-5,5])
```

 - **level** _danger_ - Текстовое представление уровня опасности (определяется пользователем, будет отражено в сообщении). Можно оставить поле пустое для экономии памяти.
 - **type** _outRange_ - Тип проверки состояния
 - **params** _[-5,5]_ - Параметры для проверки состояния

Доступные типы проверки для `BasicCondition`:

 - **isAbove** - Значение выше параметра
 - **isBelow** - Значение ниже параметра
 - **isEqual** - Значение равно параметру,
 - **outRange** - Выход за пределы параметров (требует 2 параметра),
 - **inRange** - Вход в определенные параметрами пределы (требует 2 параметра)
 - **noValue** - Если в результате запроса было получено значение `null` (не требует параметров)
 

Теперь, когда параметры определены, можно назначать их нужной метрике:

```ts
// path, query, config, id, additional
AT.watch('test.name.2',aQuery, aConfig, '', {})
```

 - **path** _test.name.2_ - Путь до метрики
 - **query** _aQuery_ - Экземпляр класса настройки запроса `AlertQuery`
 - **config** _aConfig_ - Экземпляр класса настройки проверки состояния `BasicCondition`
 - **id** _''_ - Уникальный идентификатор. Если указать пустую строку, он будет сформирован автоматически.
 - **additional** _{}_ - Дополнительные данные которые будут переданы при нарушении правила

--------

Можно назначить разным метрикам оди и теже правила и настройки запроса. **Если вы будете создавать для каждой точки отслеживания новые параметры, вы можете потерять гораздо больше памяти**

--------


Что бы получать сообщения срабатывания условия, необходимо подписаться:

```ts
AT.addListener((alert) => { console.log(alert) })
```

В случае нарушения правила, вы будете получать сообщение типа:

```ts
{
  id: '24cf92b9066b5',
  value: 7.50190642674764,
  status: 'updated',
  count: 36,
  timestamp: 1702377145,
  created: 1702377145,
  condition: {
    level: 'danger',
    id: '6633a39c10328',
    type: 'outRange',
    params: [ -5, 5 ]
  },
  areas: [ [ null, -5 ], [ 5, null ] ],
  threshholds: [ -5, 5 ],
  additional: {}
}
```

 * **id** - Идентификатор точки отслеживания (указывается в функции `watch`)
 * **value** - Результат выполнения запроса для метрики
 * **status** - Статус сообщения
     * **created** - Когда сообщение было получено первый раз
     * **updated** - Когда сообщение повторяется больше одного раза
     * **ok** - Сообщение, когда данные перестали нарушать условия
 * **count** - Количество нарушений
 * **timestamp** - Время обновлнеия
 * **created** - Время создаия
 * **condition** - Нарушеное условие
 * **areas** - Зоны условия
 * **threshholds** - Пороговое значение
 * **additional** - Дополнительная информация точки отслеживания

Areas - Зоны, всегда указываются от меньшего к большему. Например зона от 3 до 5 `[3,5]`.

Зоны могут начинаться с минус бесконечности и заканчиваться бесконечностью. В таком случае вместо значения будет указано `null`.


